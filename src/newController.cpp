/*
 * =====================================================================================
 *
 *       Filename:  newController.cpp
 *
 *    Description:  Contains simulating and input file parsing functions 
 *
 *        Version:  1.0
 *        Created:  10/1/2017 14:57:27
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Jeremy Ferlic (s), jferlic@g.harvard.edu
 *   Organization:  Harvard University
 *
 * =====================================================================================
 */

// Cell Population classes
#include "FixedPop.h"
#include "DiffTree.h"
#include "GrowingPop.h"
#include "DiffTriangle.h"

// Random Distributions and Helper functions
#include "constantRVFunctions.h"
#include "helpers.h"

// Includes
#include <iostream>
#include <fstream>
#include <deque>
#include <vector>
#include <string>
#include <algorithm>
#include <map>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <sstream>
#include <iterator>
#include <chrono>
#include <cstring>
#include <cmath>
#include <limits>
#include <gsl/gsl_randist.h>

// Rcpp headers
#include <RcppGSL.h>
#include <Rcpp.h>
#include <Rinternals.h>

// GSL random number generators
gsl_rng* rng = gsl_rng_alloc(gsl_rng_mt19937);
double seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();


// Helper Methods to read in data from text files
template
< typename T
  , template<typename ELEM, typename ALLOC=std::allocator<ELEM> > class Container
  >
std::ostream& operator<< (std::ostream& o, const Container<T>& container)
{
    typename Container<T>::const_iterator beg = container.begin();

    o << "["; // 1

    while(beg != container.end())
    {
        o << " " << *beg++; // 2
    }

    o << " ]"; // 3

    return o;
}

// trim from left
static inline std::string &ltrim(std::string &s)
{
    s.erase(s.begin(), std::find_if(s.begin(), s.end(),
                                    std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
}

// trim from end
static inline std::string &rtrim(std::string &s)
{
    s.erase(std::find_if(s.rbegin(), s.rend(),
                         std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
}

// trim from both ends
static inline std::string &trim(std::string &s)
{
    return ltrim(rtrim(s));
}


// Read in a vector matrix
std::vector<std::vector<double> > fileToVectorMatrix(std::string name)
{
    std::vector<std::vector<double> > result;
    std::ifstream input (name);
    std::string lineData;

    while(getline(input, lineData))
    {
        double d;
        std::vector<double> row;
        std::stringstream lineStream(lineData);

        while (lineStream >> d)
            row.push_back(d);

        result.push_back(row);
    }

    return result;
}

template <typename T>
std::vector<T> flatten(const std::vector<std::vector<T> >& v)
{
    std::size_t total_size = 0;
    for (const auto& sub : v)
        total_size += sub.size(); // I wish there was a transform_accumulate
    std::vector<T> result;
    result.reserve(total_size);
    for (const auto& sub : v)
        result.insert(result.end(), sub.begin(), sub.end());
    return result;
}

// Read in a vector
std::vector<double> fileToVector(std::string name)
{
    std::vector<std::vector<double> > result;
    std::ifstream input (name);
    std::string lineData;

    while(getline(input, lineData))
    {
        double d;
        std::vector<double> row;
        std::stringstream lineStream(lineData);

        while (lineStream >> d)
            row.push_back(d);

        result.push_back(row);
    }

    return flatten(result);
}

// Read in a text file, output a vector of strings, one string per line, trimmed
std::vector<std::string> inputStringVector(std::string in)
{
    std::string s;
    std::vector<std::string> a;
    std::ifstream infile(in);
    if(infile.is_open())
    {
        while(getline(infile, s))
        {
            // allow comments
            std::string::iterator end_pos = std::remove(s.begin(), s.end(), ' ');
            s.erase(end_pos, s.end());
            a.push_back(trim(s));
        }
    }

    return(a);
}


// Reads input files generated by the R code, passes this information onto the Differentiation Tree
void readInputFilesNew(std::string indir, std::map<std::string, GrowingPop*> &m, DiffTree &tree){

	// Input populations
	std::vector<std::string> names;
    names = inputStringVector(indir + "names.txt");
    std::vector<std::string> roots;
    roots = inputStringVector(indir + "roots.txt");
    std::vector<std::string> sizes;
    sizes = inputStringVector(indir + "sizes.txt");
    std::vector<std::string> types;
    types = inputStringVector(indir + "types.txt");
    std::vector<std::string> labels;
    labels = inputStringVector(indir + "labels.txt");
    std::vector<std::string> heights;
    heights = inputStringVector(indir + "heights.txt");
    std::vector<std::string> flevels;
    flevels = inputStringVector(indir + "firstlevels.txt");

	std::ifstream  src(indir + "bfs.txt", std::ios::binary);
    std::ofstream  dst(tree.opath + ".bfs",   std::ios::binary);

    dst << src.rdbuf();

    // Create Populations
    for(size_t i = 0; i < names.size(); i++)
    {
        double l = stod(labels[i]);
        if (types[i] == "CellPopulation")
        {
            long int s = stol(sizes[i]);
            m.insert(std::make_pair(names[i], new GrowingPop(names[i], s, 0, l)));
        }
        else if (types[i] == "FixedPopCell")
        {
            long int s = stol(sizes[i]);
            m.insert(std::make_pair(names[i], new FixedPop(names[i], s, 0, l)));
        }
        else if(types[i] == "DiffTriangle")
        {
            int h = stoi(heights[i]);
            int f = stoi(flevels[i]);
            m.insert(std::make_pair(names[i], new DiffTriangle(names[i], h, f) ));
        }

		// Check if this population is the root
        if (roots[i] == "TRUE")
        {
            tree.setRoot(m[names[i]]);
        }
    }

    // Create transitions
    std::vector<std::string> parent;
    parent = inputStringVector(indir + "parent.txt");
    std::vector<std::string> child;
    child = inputStringVector(indir + "child.txt");
    std::vector<std::string> diff;
    diff = inputStringVector(indir + "diff.txt");
    std::vector<std::string> rates;
    rates = inputStringVector(indir + "rates.txt");

    // Iterate over all transitions
    for(size_t i = 0; i < diff.size(); i++)
    {
        double r = stod(rates[i]);
        if (diff[i] == "alpha")
        {
            m[parent[i]]->setAlpha(r);
        }
        else if (diff[i] == "delta")
        {
            m[parent[i]]->setDeath(r);
        }
        else if (diff[i] == "gamma1")
        {
            m[parent[i]]->setDiff1(m[child[i]], r);
        }
		else if (diff[i] == "gamma2")
        {
            m[parent[i]]->setDiff2(m[child[i]], r);
        }
		else if (diff[i] == "beta")
        {
            m[parent[i]]->setAsymdiff(m[child[i]], r);
        }
        else if(diff[i] == "dediff")
        {
            m[parent[i]]->addDediff(m[child[i]], r);
        }
        else if(diff[i] == "mutation")
        {
            m[parent[i]]->setMu(r);
        }
    }

	// Fitness Distribution
	std::vector<std::string> fp;
    fp = inputStringVector(indir + "fitnessdist.txt");
	if(fp.size() > 0){
		FitnessParameters f;
		f.fitness_distribution = fp[0];
		f.is_randfitness = (fp[1] == "TRUE");
		f.alpha_fitness = stod(fp[2]);
		f.beta_fitness = stod(fp[3]);
		f.pass_prob = stod(fp[4]);
		
		if(fp[5] != "NA"){
			f.upper_fitness = stod(fp[5]); 
		} else {
			f.upper_fitness = std::numeric_limits<double>::max();
		}
		
		if(fp[6] != "NA"){
			f.lower_fitness = stod(fp[6]); 
		} else {
			f.lower_fitness = std::numeric_limits<double>::lowest();
		}
		tree.setFitnessDist(f);
	}
}


//' simulateFixedTreeCodeNew
//'
//' Runs simulation of a tree containing Fixed Population Size objects
//' [FixedPops & DiffTriangles].
//'
//'@param nObs number of observations for simulation time
//'@param traverseFrequency how often to output entire system population to filesystem
//'@param indir input directory for tree files
//'@param outdir output directory
//'@param seed numeric seed for random number generator
//'
//' @export
// [[Rcpp::export]]
int simulateFixedTreeCodeNew(int nObs = 10, int traverseFrequency = -1, std::string indir = "./", std::string outdir = "./", SEXP seed = R_NilValue)
{
	// Set the seed for the GSL random number generator
	 double seedcpp;
	if(Rf_isNull(seed)){
		seedcpp = std::chrono::high_resolution_clock::now().time_since_epoch().count();
	} else {
		seedcpp = Rf_asReal(seed);
	}
    gsl_rng_set(rng, seedcpp);

	// Create a DiffTree and give it the output path
    DiffTree tree(outdir);

	// Create a map to tie string population names to their actual object instances
    std::map<std::string, GrowingPop*> m;

	// Read input files
	readInputFilesNew(indir, m, tree);

	// Give the tree the map
	tree.setMap(m);

	// Initialize the tree, instantiates the NodeLIst data structures
	tree.initializeTree();

	// Output the initial parameters given by the user
	std::ofstream p_file;
    p_file.open(tree.opath+".params");

	p_file << "nObs\t" << nObs << std::endl;
	p_file << "traverseFrequency\t" << traverseFrequency << std::endl;
	p_file << "indir\t" << indir << std::endl;
	p_file << "outdir\t" << outdir << std::endl;
	p_file << "seed\t" << seed << std::endl;
	p_file << "fp.distribution\t" << tree.fp.fitness_distribution << std::endl;
	p_file << "fp.is_randfitness\t" << tree.fp.is_randfitness << std::endl;
	p_file << "fp.alpha_fitness\t" << tree.fp.alpha_fitness << std::endl;
	p_file << "fp.beta_fitness\t" << tree.fp.beta_fitness << std::endl;
	p_file << "fp.pass_prob\t" << tree.fp.pass_prob << std::endl;
	p_file << "fp.lower_fitness\t" << tree.fp.lower_fitness << std::endl;
	p_file << "fp.upper_fitness\t" << tree.fp.upper_fitness << std::endl;

    for(auto const& node: m)
    {
        p_file << "N_" << node.second->name << "\t" << node.second->cells.total << std::endl;
        p_file << "alpha_" << node.second->name << "\t"<< node.second->alpha << std::endl;
        p_file << "beta_" << node.second->name << "\t"<< std::accumulate(node.second->beta.begin(), node.second->beta.end(), 0.0)<< std::endl;
        p_file << "gamma1_" << node.second->name << "\t"<< std::accumulate(node.second->gamma1.begin(), node.second->gamma1.end(), 0.0) << std::endl;
		p_file << "gamma2_" << node.second->name << "\t"<< std::accumulate(node.second->gamma2.begin(), node.second->gamma2.end(), 0.0) << std::endl;
		p_file << "zeta2_" << node.second->name << "\t"<< std::accumulate(node.second->zeta.begin(), node.second->zeta.end(), 0.0) << std::endl;
        p_file << "delta_" << node.second->name << "\t"<< node.second->death << std::endl;
		p_file << "mu_" << node.second->name << "\t"<< node.second->mu << std::endl;
    }
    p_file << std::endl;
	p_file.close();

	// Calculate and adjust net proliferation for each population
	tree.calcDelta();

	// Re-output parameters after having adjusted net-proliferation
    p_file.open(tree.opath+".params2");

	p_file << "nObs\t" << nObs << std::endl;
	p_file << "traverseFrequency\t" << traverseFrequency << std::endl;
	p_file << "indir\t" << indir << std::endl;
	p_file << "outdir\t" << outdir << std::endl;
	p_file << "seed\t" << seed << std::endl;
	p_file << "fp.distribution\t" << tree.fp.fitness_distribution << std::endl;
	p_file << "fp.is_randfitness\t" << tree.fp.is_randfitness << std::endl;
	p_file << "fp.alpha_fitness\t" << tree.fp.alpha_fitness << std::endl;
	p_file << "fp.beta_fitness\t" << tree.fp.beta_fitness << std::endl;
	p_file << "fp.pass_prob\t" << tree.fp.pass_prob << std::endl;
	p_file << "fp.lower_fitness\t" << tree.fp.lower_fitness << std::endl;
	p_file << "fp.upper_fitness\t" << tree.fp.upper_fitness << std::endl;

    for(auto const& node: m)
    {
        p_file << "N_" << node.second->name << "\t" << node.second->cells.total << std::endl;
        p_file << "alpha_" << node.second->name << "\t"<< node.second->alpha << std::endl;
        p_file << "beta_" << node.second->name << "\t"<< std::accumulate(node.second->beta.begin(), node.second->beta.end(), 0.0)<< std::endl;
        p_file << "gamma1_" << node.second->name << "\t"<< std::accumulate(node.second->gamma1.begin(), node.second->gamma1.end(), 0.0) << std::endl;
		p_file << "gamma2_" << node.second->name << "\t"<< std::accumulate(node.second->gamma2.begin(), node.second->gamma2.end(), 0.0) << std::endl;
		p_file << "zeta2_" << node.second->name << "\t"<< std::accumulate(node.second->zeta.begin(), node.second->zeta.end(), 0.0) << std::endl;
        p_file << "delta_" << node.second->name << "\t"<< node.second->death << std::endl;
		p_file << "mu_" << node.second->name << "\t"<< node.second->mu << std::endl;
    }
    p_file << std::endl;
	p_file.close();

    // Create an information file - REDUNDANT DUE TO PARAMETERS FILE
	// KEPT FOR THE MOMENT FOR OLD SIMULATION RESULTS
    std::ofstream info_file;
    info_file.open(tree.opath+".info");

    for(auto const& node: m)
    {
        info_file << "N_" << node.second->name << "\t";
        info_file << "alpha_" << node.second->name << "\t";
        info_file << "beta_" << node.second->name << "\t";
        info_file << "gamma_" << node.second->name << "\t";
        info_file << "delta_" << node.second->name << "\t";
		info_file << "mu_" << node.second->name << "\t";
    }
    info_file << std::endl;

    for(auto const& node: m)
    {
        info_file << node.second->cells.total<< "\t";
        info_file << node.second->alpha << "\t";
        info_file << std::accumulate(node.second->beta.begin(), node.second->beta.end(), 0.0) << "\t";
        info_file << std::accumulate(node.second->gamma1.begin(), node.second->gamma1.end(), 0.0) << "\t";
        info_file << node.second->death << "\t";
		info_file << node.second->mu << "\t";
    }
    info_file << std::endl;
    info_file.close();

	// Print out the tree structure
    tree.print();

	// Simulate the hierarchy
    tree.time_steps(nObs, traverseFrequency);

	// RECALCULATE NET PROLIFERATION, only needed to show observed rates match expected rates
	tree.calcDelta();
	
    // Ensure NodeLists get deleted
    for ( auto current = m.begin(); current != m.end(); ++ current )
    {
        current->second->cells.deleteList();
    }
    m.clear();
    return 0;
}

//' simulateTreeCodeNew
//'
//' Runs simulation of a tree structure using Gillespie algorithm
//'
//'@param nObs number of observations for simulation time
//'@param traverseFrequency how often to output entire system population to filesystem
//'@param indir input directory for tree files
//'@param outdir output directory
//'@param seed numeric seed for random number generator
//'
//' @export
// [[Rcpp::export]]
int simulateTreeCodeNew(int nObs = 10, int traverseFrequency = -1, std::string indir = "./", std::string outdir = "./", SEXP seed = R_NilValue)
{
    int t=time(NULL);
    srand(t);

    double seedcpp;
	if(Rf_isNull(seed)){
		seedcpp = std::chrono::high_resolution_clock::now().time_since_epoch().count();
	} else {
		seedcpp = Rf_asReal(seed);
	}
    //seed = 1;
    gsl_rng_set(rng, seedcpp);


    DiffTree tree(outdir);

    std::map<std::string, GrowingPop*> m;

	readInputFilesNew(indir, m, tree);
	std::cout << "Read input files..." << std::endl;
	tree.setMap(m);

	tree.initializeTree();
	std::cout << "Initialized the tree..." << std::endl;

	// Parameters File
	std::ofstream p_file;
    p_file.open(tree.opath+".params");

	p_file << "nObs\t" << nObs << std::endl;
	p_file << "traverseFrequency\t" << traverseFrequency << std::endl;
	p_file << "indir\t" << indir << std::endl;
	p_file << "outdir\t" << outdir << std::endl;
	p_file << "seed\t" << seed << std::endl;


    for(auto const& node: m)
    {
        p_file << "N_" << node.second->name << "\t" << node.second->cells.total << std::endl;
        p_file << "alpha_" << node.second->name << "\t"<< node.second->alpha << std::endl;
        p_file << "beta_" << node.second->name << "\t"<< std::accumulate(node.second->beta.begin(), node.second->beta.end(), 0.0)<< std::endl;
        p_file << "gamma1_" << node.second->name << "\t"<< std::accumulate(node.second->gamma1.begin(), node.second->gamma1.end(), 0.0) << std::endl;
		p_file << "gamma2_" << node.second->name << "\t"<< std::accumulate(node.second->gamma2.begin(), node.second->gamma2.end(), 0.0) << std::endl;
		p_file << "zeta2_" << node.second->name << "\t"<< std::accumulate(node.second->zeta.begin(), node.second->zeta.end(), 0.0) << std::endl;
        p_file << "delta_" << node.second->name << "\t"<< node.second->death << std::endl;
		p_file << "mu_" << node.second->name << "\t"<< node.second->mu << std::endl;
    }
    p_file << std::endl;
	p_file.close();

    // INFO FILE
    std::ofstream info_file;
    info_file.open(tree.opath+".info");

    for(auto const& node: m)
    {
        info_file << "N_" << node.second->name << "\t";
        info_file << "alpha_" << node.second->name << "\t";
        info_file << "beta_" << node.second->name << "\t";
        info_file << "gamma_" << node.second->name << "\t";
        info_file << "delta_" << node.second->name << "\t";
		info_file << "mu_" << node.second->name << "\t";
    }
    info_file << std::endl;

    for(auto const& node: m)
    {
        info_file << node.second->cells.total << "\t";
        info_file << node.second->alpha << "\t";
        info_file << std::accumulate(node.second->beta.begin(), node.second->beta.end(), 0.0) << "\t";
        info_file << std::accumulate(node.second->gamma1.begin(), node.second->gamma1.end(), 0.0) << "\t";
        info_file << node.second->death << "\t";
		info_file << node.second->mu << "\t";
    }
    info_file << std::endl;
    info_file.close();

	std::cout << "Created info file..." << std::endl;
    tree.print();

    tree.simulate(nObs, traverseFrequency);

	std::cout << "Completed simulation." << std::endl;

    // Make sure NodeLists get deleted
    for ( auto current = m.begin(); current != m.end(); ++ current )
    {
		current->second->cells.deleteList();
	}
    m.clear();
    return 0;
}


