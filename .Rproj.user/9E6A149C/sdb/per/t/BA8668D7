{
    "collab_server" : "",
    "contents" : "/*\n * =====================================================================================\n *\n *       Filename:  newController.cpp\n *\n *    Description:  Contains simulating functions\n *\n *        Version:  1.0\n *        Created:  10/1/2017 14:57:27\n *       Revision:  none\n *       Compiler:  g++\n *\n *         Author:  Jeremy Ferlic (), jferlic@g.harvard.edu\n *   Organization:  Harvard University\n *\n * =====================================================================================\n */\n\n#include \"FixedPopCell.h\"\n#include \"DiffTree.h\"\n#include \"CellPopulation.h\"\n#include \"DiffTri.h\"\n#include \"FixedPopCellCode.h\"\n#include \"DiffTreeCode.h\"\n#include \"CellPopulationCode.h\"\n#include \"DiffTriCode.h\"\n\n#include <iostream>\n#include <fstream>\n#include <deque>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <stdlib.h>\n#include <time.h>\n#include <stdio.h>\n#include <sstream>\n#include <iterator>\n#include <chrono>\n#include <cstring>\n#include <cmath>\n#include <gsl/gsl_randist.h>\n\n#include <RcppGSL.h>\n#include <Rcpp.h>\n#include <Rinternals.h>\n\ngsl_rng* rng = gsl_rng_alloc(gsl_rng_mt19937);\ndouble seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();\n\ntemplate\n    < typename T\n    , template<typename ELEM, typename ALLOC=std::allocator<ELEM> > class Container\n    >\nstd::ostream& operator<< (std::ostream& o, const Container<T>& container)\n{\n    typename Container<T>::const_iterator beg = container.begin();\n\n    o << \"[\"; // 1\n\n    while(beg != container.end())\n    {\n        o << \" \" << *beg++; // 2\n    }\n\n    o << \" ]\"; // 3\n\n    return o;\n}\n\n//' simflex\n//'\n//' Simulates an example tree, no input\n//'\n//' @export\n// [[Rcpp::export]]\nint simflex(){\n\tint t=time(NULL);\n\tsrand(t);\n\n\tgsl_rng_set(rng, seed);\n\n\tint argc = 3;\n\tchar*  argv[3] = {\"simulate\", \"10\", \"1000\"};\n\n\t//command line parameters\n\tstd::string params[] = {\"executable\", \"nObs\", \"nHSC\", \"LT_death\", \"ST_death\", \"MPP_death\", \"LT_eff\", \"ST_eff\", \"MPP_eff\"};\n\tdouble LT_death = 0.0, ST_death = 0.0, MPP_death = 0.0;\n\tint nHSC = 5000, nObs = 500;\n\tdouble LT_eff = 0.173, ST_eff = 0.647, MPP_eff = 0.886;\n\n\tif(argc > 8){\n\t\tnObs = atoi(argv[1]);\n\t\tnHSC = atoi(argv[2]);\n\t\tsscanf(argv[3],\"%lf\",&LT_death);\n\t\tsscanf(argv[4],\"%lf\",&ST_death);\n\t\tsscanf(argv[5],\"%lf\",&MPP_death);\n\t\tsscanf(argv[6],\"%lf\",&LT_eff);\n\t\tsscanf(argv[7],\"%lf\",&ST_eff);\n\t\tsscanf(argv[8],\"%lf\",&MPP_eff);\n\t} else if (argc > 5) {\n\t\tnObs = atoi(argv[1]);\n\t\tnHSC = atoi(argv[2]);\n\t\tsscanf(argv[3],\"%lf\",&LT_death);\n\t\tsscanf(argv[4],\"%lf\",&ST_death);\n\t\tsscanf(argv[5],\"%lf\",&MPP_death);\n\t} else if(argc > 2){\n\t\tnObs = atoi(argv[1]);\n\t\tnHSC = atoi(argv[2]);\n\t}\n\n  nObs = 10;\n\tstd::cout << \"nHSC: \" << nHSC << std::endl;\n\n\tFixedPopCell LT(\"LT\", nHSC, 0, LT_eff); // From Busch 2015 SI Table\n\tFixedPopCell ST(\"ST\", (int) (2.9 * nHSC), 0, ST_eff); // From Busch 2015 SI Table\n\tFixedPopCell MPP(\"MPP\", (int) (9 * nHSC), 0, MPP_eff); // From Busch 2015 SI Table\n\tFixedPopCell CLP(\"CLP\", (int) (13 * nHSC), 0, 0); // ? - FixedPopCell - no self-renewal rate\n\tFixedPopCell CMP(\"CMP\", (int) (39 * nHSC), 0, 0); // ? - FixedPopCell - no self-renewal rate\n\tDiffTri MEP(\"MEP\", 3,(int) (39 * nHSC)); // ?\n\tDiffTri GMP(\"GMP\", 3,(int) (39 * nHSC)); // ?\n\tDiffTri B(\"B\", 4, (int) (13 * nHSC)); // ?\n\tDiffTri T(\"T\", 4,(int) (13 * nHSC)); //\n\tstd::cout << \"T.codes.size(): \" << T.numCells << std::endl;\n\tstd::cout << \"B2 multiplier: \" << (int) (T.numCells / 63) << std::endl;\n\tint mult_B2 = (int)(T.numCells / 63);\n\tDiffTri B2(\"B2\", 6, mult_B2);\n\tstd::cout << \"B2.codes.size(): \" << B2.numCells << std::endl;\n\n\t//std::cout << \"B.codes.size(): \" << B.codes.size() << std::endl;\n\n\tLT.addChild(&ST,   0.009); // From Busch 2015 SI Table\n\tST.addChild(&MPP,  0.045); // From Busch 2015 SI Table\n\tMPP.addChild(&CLP, 0.022); // From Busch 2015 SI Table\n\tMPP.addChild(&CMP, 3.992); // From Busch 2015 SI Table\n\t//CMP.addChild(&GMP, 2.000); // From Busch 2015 EDF 6\n\t//CMP.addChild(&MEP, 3.000); // From Busch 2015 EDF 6\n\tCLP.addChild(&B2,   2.000); // From Busch 2015 EDF 6 - note: proB\n\tCLP.addChild(&T,   2.000); // ?\n\n\n\tLT.setAlpha(0.009 + LT_death);\n\tLT.setDeath(LT_death);\n\tST.setAlpha(0.042 + ST_death);\n\tST.setDeath(ST_death);\n\tMPP.setAlpha(4.0 + MPP_death);\n\tMPP.setDeath(MPP_death);\n\n\tCLP.setAlpha(3.98);\n\n\t/*\n\tDiffTriangle2 B3(\"B3\", 5, 1);\n\tB3.printCodes();\n\tB3.add_cell(false);\n\tB3.printCodes();\n\tB3.add_cell(true);\n\tB3.printCodes();\n\tB3.add_cell(false);\n\tB3.printCodes();\n\tB3.add_cell(true);\n\tB3.printCodes();\n\tB3.add_cell(false);\n\tB3.printCodes();\n\tB3.add_cell(true);\n\tB3.printCodes();\n\t*/\n\n\tDiffTree tree(&LT);\n\t//B2.printCodes();\n\ttree.print();\n\t//tree.bfsPrint();\n\tstd::cout << tree.getRates() << std::endl;\n\n\t// INFO FILE\n\tstd::ofstream info_file;\n\tinfo_file.open(tree.opath+\".info\");\n\n\t//info_file << \"nHSC: \" << nHSC << std::endl;\n\tfor(int i = 0; i < argc; i++){\n\t\tinfo_file << params[i] << \"\\t\";\n\t}\n\n\tstd::deque<CellPopulation*> deque;\n\tdeque.push_back(tree.root);\n\twhile(deque.size() > 0){\n\n\t\tCellPopulation* node = deque.front();\n\t\tdeque.pop_front();\n\t\tinfo_file << \"N_\" << node->name << \"\\t\";\n\t\tdeque.insert( deque.end(), node->children.begin(), node->children.end() );\n\t}\n\tinfo_file << std::endl;\n\n\n\nfor(int i = 0; i < argc; i++){\n\tinfo_file << argv[i] << \"\\t\";\n}\n\ndeque.push_back(tree.root);\nwhile(deque.size() > 0){\n\n\tCellPopulation* node = deque.front();\n\tdeque.pop_front();\n\tinfo_file << node->codes.size() << \"\\t\";\n\tdeque.insert( deque.end(), node->children.begin(), node->children.end() );\n}\ninfo_file << std::endl;\ninfo_file.close();\n\n// END INFO FILE\n\n\n//tree.simulate(nObs);\ntree.time_steps(nObs);\n\n\nreturn 0;\n}\n\nstatic inline std::string &ltrim(std::string &s) {\n  s.erase(s.begin(), std::find_if(s.begin(), s.end(),\n                  std::not1(std::ptr_fun<int, int>(std::isspace))));\n  return s;\n}\n\n// trim from end\nstatic inline std::string &rtrim(std::string &s) {\n  s.erase(std::find_if(s.rbegin(), s.rend(),\n                       std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());\n  return s;\n}\n\n// trim from both ends\nstatic inline std::string &trim(std::string &s) {\n  return ltrim(rtrim(s));\n}\n\nstd::vector<std::vector<double> > fileToVectorMatrix(std::string name)\n{\n  std::vector<std::vector<double> > result;\n  std::ifstream input (name);\n  std::string lineData;\n\n  while(getline(input, lineData))\n  {\n    double d;\n    std::vector<double> row;\n    std::stringstream lineStream(lineData);\n\n    while (lineStream >> d)\n      row.push_back(d);\n\n    result.push_back(row);\n  }\n\n  return result;\n}\n\ntemplate <typename T>\nstd::vector<T> flatten(const std::vector<std::vector<T> >& v) {\nstd::size_t total_size = 0;\nfor (const auto& sub : v)\n  total_size += sub.size(); // I wish there was a transform_accumulate\nstd::vector<T> result;\nresult.reserve(total_size);\nfor (const auto& sub : v)\n  result.insert(result.end(), sub.begin(), sub.end());\nreturn result;\n}\n\nstd::vector<double> fileToVector(std::string name)\n{\nstd::vector<std::vector<double> > result;\nstd::ifstream input (name);\nstd::string lineData;\n\nwhile(getline(input, lineData))\n{\n  double d;\n  std::vector<double> row;\n  std::stringstream lineStream(lineData);\n\n  while (lineStream >> d)\n    row.push_back(d);\n\n  result.push_back(row);\n}\n\nreturn flatten(result);\n}\n\nstd::vector<std::string> inputStringVector(std::string in){\n  std::string s;\n  std::vector<std::string> a;\n  std::ifstream infile(in);\n  if(infile.is_open())\n  {\n    while(getline(infile, s))\n    {\n      // allow comments\n      std::string::iterator end_pos = std::remove(s.begin(), s.end(), ' ');\n      s.erase(end_pos, s.end());\n      a.push_back(trim(s));\n    }\n  }\n\n  return(a);\n}\n\n\n//' simulateFixedTree\n//'\n//' Runs simulation of a tree containing Fixed Population Size objects\n//' [FixedPopCells & DiffTriangles].\n//'\n//'@param nObs number of observations for simulation time\n//'@param indir input directory for tree files\n//'@param outdir output directory\n//'\n//' @export\n// [[Rcpp::export]]\nint simulateFixedTree(int nObs = 10, std::string indir = \"./\", std::string outdir = \"./\"){\n\n  seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();\n  gsl_rng_set(rng, seed);\n\n  std::vector<std::string> names;\n  names = inputStringVector(indir + \"names.txt\");\n  std::vector<std::string> roots;\n  roots = inputStringVector(indir + \"roots.txt\");\n  std::vector<std::string> sizes;\n  sizes = inputStringVector(indir + \"sizes.txt\");\n  std::vector<std::string> types;\n  types = inputStringVector(indir + \"types.txt\");\n  std::vector<std::string> labels;\n  labels = inputStringVector(indir + \"labels.txt\");\n  std::vector<std::string> heights;\n  heights = inputStringVector(indir + \"heights.txt\");\n  std::vector<std::string> flevels;\n  flevels = inputStringVector(indir + \"firstlevels.txt\");\n\n  DiffTree tree(outdir);\n\n  std::map<std::string, CellPopulation*> m;\n\n  // NODES\n  for(int i = 0; i < names.size(); i++){\n    double l = stod(labels[i]);\n    //cout << types[i] << endl;\n    if (types[i] == \"CellPopulation\"){\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new CellPopulation named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new CellPopulation(names[i], s, 0, l)));\n    } else if (types[i] == \"FixedPopCell\") {\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new FixedPopCell named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new FixedPopCell(names[i], s, 0, l)));\n    } else if(types[i] == \"DiffTriangle\"){\n      int h = stoi(heights[i]);\n      int f = stoi(flevels[i]);\n      //cout << \"I'm making a new DiffTriangle named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new DiffTri(names[i], h, f) ));\n    }\n\n    if (roots[i] == \"TRUE\"){\n      tree.setRoot(m[names[i]]);\n    }\n  }\n\n  // EDGES\n\n  std::vector<std::string> parent;\n  parent = inputStringVector(indir + \"parent.txt\");\n  std::vector<std::string> child;\n  child = inputStringVector(indir + \"child.txt\");\n  std::vector<std::string> diff;\n  diff = inputStringVector(indir + \"diff.txt\");\n  std::vector<std::string> rates;\n  rates = inputStringVector(indir + \"rates.txt\");\n\n  //cout << diff.size() << endl;\n  for(int i = 0; i < diff.size(); i++){\n    double r = stod(rates[i]);\n    if (diff[i] == \"alpha\"){\n      m[parent[i]]->setAlpha(r);\n    } else if (diff[i] == \"delta\") {\n      m[parent[i]]->setDeath(r);\n    } else if (diff[i] == \"gamma\") {\n      m[parent[i]]->addChild(m[child[i]], r);\n    } else if(diff[i] == \"dediff\"){\n      m[parent[i]]->addDediff(m[child[i]], r);\n    }\n\n    //else if (diff[i].compare(\"beta\")) {\n    //m.insert(std::make_pair(names[i], new FixedPopCell(names[i], s)));\n    //}\n  }\n\n  // INFO FILE\n  std::ofstream info_file;\n  info_file.open(tree.opath+\".info\");\n\n  /*\n  std::deque<CellPopulation*> deque;\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n  CellPopulation* node = deque.front();\n  deque.pop_front();\n  info_file << \"N_\" << node->name << \"\\t\";\n  info_file << \"alpha_\" << node->name << \"\\t\";\n  info_file << \"beta_\" << node->name << \"\\t\";\n  info_file << \"gamma_\" << node->name << \"\\t\";\n  info_file << \"delta_\" << node->name << \"\\t\";\n  deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n  */\n\n  for(auto const& node: m){\n    info_file << \"N_\" << node.second->name << \"\\t\";\n    info_file << \"alpha_\" << node.second->name << \"\\t\";\n    info_file << \"beta_\" << node.second->name << \"\\t\";\n    info_file << \"gamma_\" << node.second->name << \"\\t\";\n    info_file << \"delta_\" << node.second->name << \"\\t\";\n  }\n  info_file << std::endl;\n\n  /*\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n  CellPopulation* node = deque.front();\n  deque.pop_front();\n  info_file << node->codes.size() << \"\\t\";\n  info_file << node->alpha << \"\\t\";\n  info_file << node->beta << \"\\t\";\n  info_file << std::accumulate(node->diff_rates.begin(), node->diff_rates.end(), 0.0) << \"\\t\";\n  info_file << node->death << \"\\t\";\n  deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n  */\n  for(auto const& node: m){\n    info_file << node.second->codes.size() << \"\\t\";\n    info_file << node.second->alpha << \"\\t\";\n    info_file << node.second->beta << \"\\t\";\n    info_file << std::accumulate(node.second->diff_rates.begin(), node.second->diff_rates.end(), 0.0) << \"\\t\";\n    info_file << node.second->death << \"\\t\";\n  }\n  info_file << std::endl;\n  info_file.close();\n\n  tree.print();\n  tree.setMap(m);\n  tree.time_steps(nObs);\n\n  // No dynamic memory to delete\n  for ( auto current = m.begin(); current != m.end(); ++ current ) {\n    //delete current->second;\n  }\n  m.clear();\n  return 0;\n}\n\n//' simulateTree\n//'\n//' Runs simulation of a tree structure using Gillespie algorithm\n//'\n//'@param nObs number of observations for simulation time\n//'@param indir input directory for tree files\n//'@param outdir output directory\n//'\n//' @export\n// [[Rcpp::export]]\nint simulateTree(int nObs = 10, std::string indir = \"./\", std::string outdir = \"./\"){\n  int t=time(NULL);\n  srand(t);\n\n  seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();\n  gsl_rng_set(rng, seed);\n\n  // std::vector<std::string> b;\n  //b = inputStringVector(indir + \"in.txt\");\n\n  std::vector<std::string> names;\n  names = inputStringVector(indir + \"names.txt\");\n  std::vector<std::string> roots;\n  roots = inputStringVector(indir + \"roots.txt\");\n  std::vector<std::string> sizes;\n  sizes = inputStringVector(indir + \"sizes.txt\");\n  std::vector<std::string> types;\n  types = inputStringVector(indir + \"types.txt\");\n  std::vector<std::string> labels;\n  labels = inputStringVector(indir + \"labels.txt\");\n  std::vector<std::string> heights;\n  heights = inputStringVector(indir + \"heights.txt\");\n  std::vector<std::string> flevels;\n  flevels = inputStringVector(indir + \"firstlevels.txt\");\n\n  DiffTree tree(outdir);\n\n  std::map<std::string, CellPopulation*> m;\n\n  // NODES\n  for(int i = 0; i < names.size(); i++){\n    double l = stod(labels[i]);\n    //cout << types[i] << endl;\n    if (types[i] == \"CellPopulation\"){\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new CellPopulation named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new CellPopulation(names[i], s, 0, l)));\n    } else if (types[i] == \"FixedPopCell\") {\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new FixedPopCell named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new FixedPopCell(names[i], s, 0, l)));\n    } else if(types[i] == \"DiffTriangle\"){\n      int h = stoi(heights[i]);\n      int f = stoi(flevels[i]);\n      //cout << \"I'm making a new DiffTriangle named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new DiffTri(names[i], h, f) ));\n    }\n\n    if (roots[i] == \"TRUE\"){\n      tree.setRoot(m[names[i]]);\n    }\n  }\n\n  // EDGES\n\n  std::vector<std::string> parent;\n  parent = inputStringVector(indir + \"parent.txt\");\n  std::vector<std::string> child;\n  child = inputStringVector(indir + \"child.txt\");\n  std::vector<std::string> diff;\n  diff = inputStringVector(indir + \"diff.txt\");\n  std::vector<std::string> rates;\n  rates = inputStringVector(indir + \"rates.txt\");\n\n  //cout << diff.size() << endl;\n  for(int i = 0; i < diff.size(); i++){\n    double r = stod(rates[i]);\n    if (diff[i] == \"alpha\"){\n      m[parent[i]]->setAlpha(r);\n    } else if (diff[i] == \"delta\") {\n      m[parent[i]]->setDeath(r);\n    } else if (diff[i] == \"gamma\") {\n      m[parent[i]]->addChild(m[child[i]], r,0.0);\n    } else if(diff[i] == \"dediff\"){\n      m[parent[i]]->addDediff(m[child[i]], r);\n    }//else if (diff[i].compare(\"beta\")) {\n    //m.insert(std::make_pair(names[i], new FixedPopCell(names[i], s)));\n    //}\n  }\n\n  // INFO FILE\n  std::ofstream info_file;\n  info_file.open(tree.opath+\".info\");\n\n  /*\n  std::deque<CellPopulation*> deque;\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n    CellPopulation* node = deque.front();\n    deque.pop_front();\n    info_file << \"N_\" << node->name << \"\\t\";\n    info_file << \"alpha_\" << node->name << \"\\t\";\n    info_file << \"beta_\" << node->name << \"\\t\";\n    info_file << \"gamma_\" << node->name << \"\\t\";\n    info_file << \"delta_\" << node->name << \"\\t\";\n    deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n   */\n\n  for(auto const& node: m){\n    info_file << \"N_\" << node.second->name << \"\\t\";\n    info_file << \"alpha_\" << node.second->name << \"\\t\";\n    info_file << \"beta_\" << node.second->name << \"\\t\";\n    info_file << \"gamma_\" << node.second->name << \"\\t\";\n    info_file << \"delta_\" << node.second->name << \"\\t\";\n  }\n  info_file << std::endl;\n\n  /*\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n    CellPopulation* node = deque.front();\n    deque.pop_front();\n    info_file << node->codes.size() << \"\\t\";\n    info_file << node->alpha << \"\\t\";\n    info_file << node->beta << \"\\t\";\n    info_file << std::accumulate(node->diff_rates.begin(), node->diff_rates.end(), 0.0) << \"\\t\";\n    info_file << node->death << \"\\t\";\n    deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n   */\n  for(auto const& node: m){\n    info_file << node.second->codes.size() << \"\\t\";\n    info_file << node.second->alpha << \"\\t\";\n    info_file << node.second->beta << \"\\t\";\n    info_file << std::accumulate(node.second->diff_rates.begin(), node.second->diff_rates.end(), 0.0) << \"\\t\";\n    info_file << node.second->death << \"\\t\";\n  }\n  info_file << std::endl;\n  info_file.close();\n\n  tree.print();\n  tree.setMap(m);\n  tree.simulate(nObs);\n\n  // No dynamic memory to delete\n  for ( auto current = m.begin(); current != m.end(); ++ current ) {\n    //delete current->second;\n  }\n  m.clear();\n  return 0;\n}\n\n//' simulateFixedTreeCode\n//'\n//' Runs simulation of a tree containing Fixed Population Size objects\n//' [FixedPopCellCodes & DiffTriCodeangles].\n//'\n//'@param nObs number of observations for simulation time\n//'@param indir input directory for tree files\n//'@param outdir output directory\n//'\n//' @export\n// [[Rcpp::export]]\nint simulateFixedTreeCode(int nObs = 10, std::string indir = \"./\", std::string outdir = \"./\"){\n\n  seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();\n  gsl_rng_set(rng, seed);\n\n  std::vector<std::string> names;\n  names = inputStringVector(indir + \"names.txt\");\n  std::vector<std::string> roots;\n  roots = inputStringVector(indir + \"roots.txt\");\n  std::vector<std::string> sizes;\n  sizes = inputStringVector(indir + \"sizes.txt\");\n  std::vector<std::string> types;\n  types = inputStringVector(indir + \"types.txt\");\n  std::vector<std::string> labels;\n  labels = inputStringVector(indir + \"labels.txt\");\n  std::vector<std::string> heights;\n  heights = inputStringVector(indir + \"heights.txt\");\n  std::vector<std::string> flevels;\n  flevels = inputStringVector(indir + \"firstlevels.txt\");\n\n  DiffTreeCode tree(outdir);\n\n  std::map<std::string, CellPopulationCode*> m;\n\n  // NODES\n  for(int i = 0; i < names.size(); i++){\n    double l = stod(labels[i]);\n    //cout << types[i] << endl;\n    if (types[i] == \"CellPopulation\"){\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new CellPopulationCode named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new CellPopulationCode(names[i], s, 0, l)));\n    } else if (types[i] == \"FixedPopCell\") {\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new FixedPopCellCode named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new FixedPopCellCode(names[i], s, 0, l)));\n    } else if(types[i] == \"DiffTriangle\"){\n      int h = stoi(heights[i]);\n      int f = stoi(flevels[i]);\n      //cout << \"I'm making a new DiffTriCodeangle named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new DiffTriCode(names[i], h, f) ));\n    }\n\n    if (roots[i] == \"TRUE\"){\n      tree.setRoot(m[names[i]]);\n    }\n  }\n\n  // EDGES\n\n  std::vector<std::string> parent;\n  parent = inputStringVector(indir + \"parent.txt\");\n  std::vector<std::string> child;\n  child = inputStringVector(indir + \"child.txt\");\n  std::vector<std::string> diff;\n  diff = inputStringVector(indir + \"diff.txt\");\n  std::vector<std::string> rates;\n  rates = inputStringVector(indir + \"rates.txt\");\n\n  //cout << diff.size() << endl;\n  for(int i = 0; i < diff.size(); i++){\n    double r = stod(rates[i]);\n    if (diff[i] == \"alpha\"){\n      m[parent[i]]->setAlpha(r);\n    } else if (diff[i] == \"delta\") {\n      m[parent[i]]->setDeath(r);\n    } else if (diff[i] == \"gamma\") {\n      m[parent[i]]->addChild(m[child[i]], r);\n    } else if(diff[i] == \"dediff\"){\n      m[parent[i]]->addDediff(m[child[i]], r);\n    } //else if (diff[i].compare(\"beta\")) {\n    //m.insert(std::make_pair(names[i], new FixedPopCellCode(names[i], s)));\n    //}\n  }\n\n  // INFO FILE\n  std::ofstream info_file;\n  info_file.open(tree.opath+\".info\");\n\n  /*\n  std::deque<CellPopulationCode*> deque;\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n  CellPopulationCode* node = deque.front();\n  deque.pop_front();\n  info_file << \"N_\" << node->name << \"\\t\";\n  info_file << \"alpha_\" << node->name << \"\\t\";\n  info_file << \"beta_\" << node->name << \"\\t\";\n  info_file << \"gamma_\" << node->name << \"\\t\";\n  info_file << \"delta_\" << node->name << \"\\t\";\n  deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n  */\n\n  for(auto const& node: m){\n    info_file << \"N_\" << node.second->name << \"\\t\";\n    info_file << \"alpha_\" << node.second->name << \"\\t\";\n    info_file << \"beta_\" << node.second->name << \"\\t\";\n    info_file << \"gamma_\" << node.second->name << \"\\t\";\n    info_file << \"delta_\" << node.second->name << \"\\t\";\n  }\n  info_file << std::endl;\n\n  /*\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n  CellPopulationCode* node = deque.front();\n  deque.pop_front();\n  info_file << node->codes.size() << \"\\t\";\n  info_file << node->alpha << \"\\t\";\n  info_file << node->beta << \"\\t\";\n  info_file << std::accumulate(node->diff_rates.begin(), node->diff_rates.end(), 0.0) << \"\\t\";\n  info_file << node->death << \"\\t\";\n  deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n  */\n  for(auto const& node: m){\n    info_file << node.second->codes.size() << \"\\t\";\n    info_file << node.second->alpha << \"\\t\";\n    info_file << node.second->beta << \"\\t\";\n    info_file << std::accumulate(node.second->diff_rates.begin(), node.second->diff_rates.end(), 0.0) << \"\\t\";\n    info_file << node.second->death << \"\\t\";\n  }\n  info_file << std::endl;\n  info_file.close();\n\n  tree.print();\n  tree.setMap(m);\n  tree.time_steps(nObs);\n\n  // No dynamic memory to delete\n  for ( auto current = m.begin(); current != m.end(); ++ current ) {\n    //delete current->second;\n  }\n  m.clear();\n  return 0;\n}\n\n//' simulateTreeCode\n//'\n//' Runs simulation of a tree structure using Gillespie algorithm\n//'\n//'@param nObs number of observations for simulation time\n//'@param indir input directory for tree files\n//'@param outdir output directory\n//'\n//' @export\n// [[Rcpp::export]]\nint simulateTreeCode(int nObs = 10, std::string indir = \"./\", std::string outdir = \"./\"){\n  int t=time(NULL);\n  srand(t);\n\n  seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();\n  gsl_rng_set(rng, seed);\n\n  // std::vector<std::string> b;\n  //b = inputStringVector(indir + \"in.txt\");\n\n  std::vector<std::string> names;\n  names = inputStringVector(indir + \"names.txt\");\n  std::vector<std::string> roots;\n  roots = inputStringVector(indir + \"roots.txt\");\n  std::vector<std::string> sizes;\n  sizes = inputStringVector(indir + \"sizes.txt\");\n  std::vector<std::string> types;\n  types = inputStringVector(indir + \"types.txt\");\n  std::vector<std::string> labels;\n  labels = inputStringVector(indir + \"labels.txt\");\n  std::vector<std::string> heights;\n  heights = inputStringVector(indir + \"heights.txt\");\n  std::vector<std::string> flevels;\n  flevels = inputStringVector(indir + \"firstlevels.txt\");\n\n  DiffTreeCode tree(outdir);\n\n  std::map<std::string, CellPopulationCode*> m;\n\n  // NODES\n  for(int i = 0; i < names.size(); i++){\n    double l = stod(labels[i]);\n    //cout << types[i] << endl;\n    if (types[i] == \"CellPopulation\"){\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new CellPopulationCode named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new CellPopulationCode(names[i], s, 0, l)));\n    } else if (types[i] == \"FixedPopCell\") {\n      long int s = stol(sizes[i]);\n      //cout << \"I'm making a new FixedPopCellCode named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new FixedPopCellCode(names[i], s, 0, l)));\n    } else if(types[i] == \"DiffTriangle\"){\n      int h = stoi(heights[i]);\n      int f = stoi(flevels[i]);\n      //cout << \"I'm making a new DiffTriCodeangle named \" << names[i] << endl;\n      m.insert(std::make_pair(names[i], new DiffTriCode(names[i], h, f) ));\n    }\n\n    if (roots[i] == \"TRUE\"){\n      tree.setRoot(m[names[i]]);\n    }\n  }\n\n\n  // EDGES\n\n  std::vector<std::string> parent;\n  parent = inputStringVector(indir + \"parent.txt\");\n  std::vector<std::string> child;\n  child = inputStringVector(indir + \"child.txt\");\n  std::vector<std::string> diff;\n  diff = inputStringVector(indir + \"diff.txt\");\n  std::vector<std::string> rates;\n  rates = inputStringVector(indir + \"rates.txt\");\n\n  //cout << diff.size() << endl;\n  for(int i = 0; i < diff.size(); i++){\n\n    double r = stod(rates[i]);\n\n    if (diff[i] == \"alpha\"){\n      m[parent[i]]->setAlpha(r);\n    } else if (diff[i] == \"delta\") {\n      m[parent[i]]->setDeath(r);\n    } else if (diff[i] == \"gamma\") {\n      m[parent[i]]->addChild(m[child[i]], r);\n    } else if(diff[i] == \"dediff\"){\n      m[parent[i]]->addDediff(m[child[i]], r);\n    }//else if (diff[i].compare(\"beta\")) {\n    //m.insert(std::make_pair(names[i], new FixedPopCellCode(names[i], s)));\n    //}\n  }\n\n  // INFO FILE\n  std::ofstream info_file;\n  info_file.open(tree.opath+\".info\");\n\n  /*\n  std::deque<CellPopulationCode*> deque;\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n  CellPopulationCode* node = deque.front();\n  deque.pop_front();\n  info_file << \"N_\" << node->name << \"\\t\";\n  info_file << \"alpha_\" << node->name << \"\\t\";\n  info_file << \"beta_\" << node->name << \"\\t\";\n  info_file << \"gamma_\" << node->name << \"\\t\";\n  info_file << \"delta_\" << node->name << \"\\t\";\n  deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n  */\n\n  for(auto const& node: m){\n    info_file << \"N_\" << node.second->name << \"\\t\";\n    info_file << \"alpha_\" << node.second->name << \"\\t\";\n    info_file << \"beta_\" << node.second->name << \"\\t\";\n    info_file << \"gamma_\" << node.second->name << \"\\t\";\n    info_file << \"delta_\" << node.second->name << \"\\t\";\n  }\n  info_file << std::endl;\n\n  /*\n  deque.push_back(tree.root);\n  while(deque.size() > 0){\n\n  CellPopulationCode* node = deque.front();\n  deque.pop_front();\n  info_file << node->codes.size() << \"\\t\";\n  info_file << node->alpha << \"\\t\";\n  info_file << node->beta << \"\\t\";\n  info_file << std::accumulate(node->diff_rates.begin(), node->diff_rates.end(), 0.0) << \"\\t\";\n  info_file << node->death << \"\\t\";\n  deque.insert( deque.end(), node->children.begin(), node->children.end() );\n  }\n  */\n  for(auto const& node: m){\n    info_file << node.second->codes.size() << \"\\t\";\n    info_file << node.second->alpha << \"\\t\";\n    info_file << node.second->beta << \"\\t\";\n    info_file << std::accumulate(node.second->diff_rates.begin(), node.second->diff_rates.end(), 0.0) << \"\\t\";\n    info_file << node.second->death << \"\\t\";\n  }\n  info_file << std::endl;\n  info_file.close();\n\n  tree.print();\n  tree.setMap(m);\n  tree.simulate(nObs);\n\n  // No dynamic memory to delete\n  for ( auto current = m.begin(); current != m.end(); ++ current ) {\n    //delete current->second;\n  }\n  m.clear();\n  return 0;\n}\n",
    "created" : 1508259150808.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "56|1|69|0|\n77|14|219|0|\n221|50|225|0|\n228|50|232|0|\n235|49|237|0|\n240|1|258|0|\n261|63|270|0|\n273|1|291|0|\n293|59|309|0|\n323|90|463|0|\n781|89|927|0|\n",
    "hash" : "2349038056",
    "id" : "BA8668D7",
    "lastKnownWriteTime" : 1508264979,
    "last_content_update" : 1508264979604,
    "path" : "~/Documents/Jeremy/flex/flex/src/newController.cpp",
    "project_path" : "src/newController.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}